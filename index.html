<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Virtual Abacus (Final Layout)</title>
    <style>
        /* --- General Layout --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
            user-select: none; /* Prevent text selection during drag */
        }

        h1 {
            color: #4a3424;
            margin-bottom: 20px;
        }

        /* --- Canvas Container and Styling --- */
        #abacusCanvas {
            border: 10px solid #4a3424; /* Frame */
            border-radius: 12px;
            background-color: #6b4e3c; /* Abacus body wood color */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            margin-bottom: 30px;
            cursor: default;
        }

        /* --- Value Display --- */
        #value-display {
            font-size: 2.5em;
            color: #2c1a10;
            font-weight: bold;
            padding: 15px 30px;
            border: 3px solid #2c1a10;
            border-radius: 10px;
            background-color: #fff;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            min-width: 300px;
            text-align: center;
        }
    </style>
</head>
<body>

    <h1>Canvas Virtual Abacus (Final Layout)</h1>

    <canvas id="abacusCanvas"></canvas>

    <div id="value-display">0</div>

    <script>
        // --- CANVAS JAVASCRIPT LOGIC ---

        const canvas = document.getElementById('abacusCanvas');
        const ctx = canvas.getContext('2d');
        const valueDisplay = document.getElementById('value-display');

        // --- CONFIGURATION ---
        const NUM_RODS = 10;
        const ROD_SPACING = 50; 
        const BEAD_RADIUS = 18;
        const BEAD_DIAMETER = BEAD_RADIUS * 2;
        const BEAM_HEIGHT = 18;
        const PADDING = 5; // Padding from the frame edge
        
        // Calculate canvas dimensions
        canvas.width = (NUM_RODS * ROD_SPACING) + ROD_SPACING; 
        canvas.height = 350;

        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;

        // --- DYNAMIC SECTION HEIGHTS (Fix for Proportional Spacing) ---
        
        // Height required for the 4 Earth beads + minimal top/bottom padding
        const MIN_BOTTOM_HEIGHT = (4 * BEAD_DIAMETER) + (4 * PADDING) + (2 * PADDING);

        // Height required for 1 Heaven bead + minimal top padding
        const MIN_TOP_HEIGHT = BEAD_DIAMETER + (2 * PADDING);

        // We use the entire height and dynamically calculate the beam position
        // to maintain a better 1:4 visual balance.
        
        // The total height taken by all beads and spacing:
        const TOTAL_BEAD_HEIGHT_NEEDED = MIN_TOP_HEIGHT + MIN_BOTTOM_HEIGHT + BEAM_HEIGHT;
        
        // Use a fixed proportion for the beam: Top section is ~1/5th, bottom ~4/5ths.
        const TOP_SECTION_RATIO = 0.25; // 25% of space above beam, 75% below

        // Y position of the beam's center line
        const BEAM_Y = (CANVAS_HEIGHT * TOP_SECTION_RATIO); 

        // Actual boundaries based on the new BEAM_Y
        const TOP_SECTION_HEIGHT = BEAM_Y - (BEAM_HEIGHT / 2); // Top edge of the beam
        const BOTTOM_SECTION_START_Y = BEAM_Y + (BEAM_HEIGHT / 2); // Bottom edge of the beam

        // Calculate spacing based on the available space
        const HEAVEN_BEAD_STACK_Y = TOP_SECTION_HEIGHT - BEAD_RADIUS; // Pushed: Snaps to the beam
        const HEAVEN_BEAD_UNSTACK_Y = PADDING + BEAD_RADIUS; // Unpushed: Snaps to the top frame

        const EARTH_BEAD_STACK_UNIT = (BEAD_DIAMETER + PADDING); // Spacing for stacked beads
        const EARTH_BEAD_UNSTACK_UNIT = (BEAD_DIAMETER + PADDING); // Spacing for unstacked beads

        // --- DATA STRUCTURE & CLASSES (Unchanged) ---
        const rods = []; 
        let isDragging = false;

        class Bead {
            constructor(x, y, section, rodIndex, beadIndex) {
                this.x = x;
                this.y = y;
                this.section = section;
                this.rodIndex = rodIndex;
                this.beadIndex = beadIndex;
                this.pushed = false;
                this.value = (section === 'top' ? 5 : 1);
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, BEAD_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = this.section === 'top' ? '#007bff' : '#dc3545';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.fill();
                ctx.shadowColor = 'transparent'; 
            }

            isHit(mouseX, mouseY) {
                const distance = Math.sqrt(
                    (mouseX - this.x) ** 2 + (mouseY - this.y) ** 2
                );
                return distance < BEAD_RADIUS;
            }
        }

        // --- INITIALIZATION (Updated Y positions) ---
        function initAbacus() {
            for (let i = 0; i < NUM_RODS; i++) {
                const rodX = (i * ROD_SPACING) + ROD_SPACING / 2 + ROD_SPACING / 2;
                const rodBeads = [];

                // 1. Heaven Bead (Top)
                rodBeads.push(new Bead(rodX, HEAVEN_BEAD_UNSTACK_Y, 'top', i, 0));

                // 2. Earth Beads (Bottom)
                for (let j = 0; j < 4; j++) {
                    const initialY = CANVAS_HEIGHT - PADDING - BEAD_RADIUS - (j * EARTH_BEAD_UNSTACK_UNIT);
                    rodBeads.push(new Bead(rodX, initialY, 'bottom', i, j));
                }
                rods.push(rodBeads);
            }
            recalculateAllBeads();
        }

        // --- DRAWING (Unchanged) ---
        function drawRod(x) {
            ctx.fillStyle = '#a07d6a';
            ctx.fillRect(x - 1.5, 0, 3, CANVAS_HEIGHT); 

            ctx.fillStyle = '#f0f0f0';
            ctx.beginPath();
            ctx.arc(x, BEAM_Y, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawReckoningBar() {
            ctx.fillStyle = '#2c1a10';
            ctx.fillRect(0, BEAM_Y - BEAM_HEIGHT / 2, CANVAS_WIDTH, BEAM_HEIGHT);
            
            ctx.fillStyle = '#5a3c2a';
            ctx.fillRect(0, BEAM_Y - BEAM_HEIGHT / 2, CANVAS_WIDTH, 2);
            ctx.fillRect(0, BEAM_Y + BEAM_HEIGHT / 2 - 2, CANVAS_WIDTH, 2);
        }

        function drawAbacus() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawReckoningBar();

            // Draw rods
            rods.flat().forEach(bead => drawRod(bead.x));
            
            // Draw all beads on top of the rods
            rods.flat().forEach(bead => bead.draw(ctx));
        }

        // --- LOGIC: MOVEMENT & SNAPPING (Fix for Bug 1: Hit Detection) ---

        let draggingBead = null;
        let beadOffsetY = 0; 

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleStart(e) {
            e.preventDefault();
            const pos = getMousePos(e);
            
            // FIX: Prioritize checking beads that are visually on top.
            // Pushed Earth beads stack near the beam, unpushed near the bottom.
            // We check the entire flat list in reverse Y-order to catch the visually highest bead first.
            
            const allBeads = rods.flat().sort((a, b) => b.y - a.y); // Sort by Y (highest Y, lowest on screen, checked first)

            for (const bead of allBeads) {
                if (bead.isHit(pos.x, pos.y)) {
                    draggingBead = bead;
                    beadOffsetY = pos.y - bead.y; 
                    canvas.style.cursor = 'grabbing';
                    isDragging = false;
                    break;
                }
            }
        }

        function handleMove(e) {
            if (!draggingBead) return;
            e.preventDefault(); 
            isDragging = true;
            
            const pos = getMousePos(e);
            let newY = pos.y - beadOffsetY;

            // --- Enforce Boundaries ---
            if (draggingBead.section === 'top') {
                const min = PADDING + BEAD_RADIUS;
                const max = TOP_SECTION_HEIGHT - BEAD_RADIUS;
                draggingBead.y = Math.max(min, Math.min(max, newY));
            } else {
                const min = BOTTOM_SECTION_START_Y + BEAD_RADIUS;
                const max = CANVAS_HEIGHT - PADDING - BEAD_RADIUS;
                draggingBead.y = Math.max(min, Math.min(max, newY));
            }

            drawAbacus();
        }

        function handleEnd(e) {
            if (!draggingBead) return;

            // Determine if the bead is "pushed" based on its final position
            if (draggingBead.section === 'top') {
                // Snap point is the vertical center of the top section
                const snapPoint = (HEAVEN_BEAD_STACK_Y + HEAVEN_BEAD_UNSTACK_Y) / 2;
                draggingBead.pushed = draggingBead.y > snapPoint;
            } else {
                // Snap point is the vertical center of the bottom section
                const snapPoint = (CANVAS_HEIGHT + BOTTOM_SECTION_START_Y) / 2;
                draggingBead.pushed = draggingBead.y < snapPoint;
            }

            // Recalculate and snap all beads in the column
            recalculateRodBeads(draggingBead.rodIndex);

            draggingBead = null;
            canvas.style.cursor = 'default';
        }

        function handleClick(e) {
            if (isDragging) return; 

            const pos = getMousePos(e);
            
            // Use the same robust hit detection as handleStart
            const bead = rods.flat().sort((a, b) => b.y - a.y).find(b => b.isHit(pos.x, pos.y));
            
            if (bead) {
                bead.pushed = !bead.pushed;
                recalculateRodBeads(bead.rodIndex);
            }
        }

        // --- FINAL POSITIONING AND VALUE CALCULATION ---
        function recalculateRodBeads(rodIndex) {
            const rodBeads = rods[rodIndex];
            
            let pushedBottomCount = 0; 

            // 1. Process Heaven Bead (Value 5)
            const heavenBead = rodBeads.find(b => b.section === 'top');
            if (heavenBead.pushed) {
                heavenBead.y = HEAVEN_BEAD_STACK_Y; 
            } else {
                heavenBead.y = HEAVEN_BEAD_UNSTACK_Y;
            }

            // 2. Process Earth Beads (Value 1) and Stacking
            const earthBeads = rodBeads.filter(b => b.section === 'bottom').sort((a, b) => 
                a.beadIndex - b.beadIndex
            );

            // First pass: Count pushed beads
            earthBeads.forEach(bead => {
                if (bead.pushed) pushedBottomCount++;
            });

            let currentPushedStack = 0;
            let currentUnpushedStack = 0;

            // Second pass: Apply final Y position based on stacking
            earthBeads.forEach(bead => {
                if (bead.pushed) {
                    // Pushed: Stack up from the bottom of the beam
                    bead.y = BOTTOM_SECTION_START_Y + BEAD_RADIUS + (currentPushedStack * EARTH_BEAD_STACK_UNIT);
                    currentPushedStack++;
                } else {
                    // Unpushed: Stack down from the bottom frame (uses beadIndex for correct order)
                    // (3 - bead.beadIndex) is used to map bead 0 to the highest position, bead 3 to the lowest
                    bead.y = CANVAS_HEIGHT - PADDING - BEAD_RADIUS - ((3 - bead.beadIndex) * EARTH_BEAD_UNSTACK_UNIT);
                    currentUnpushedStack++;
                }
            });
            
            updateTotalValue();
            drawAbacus();
        }
        
        function recalculateAllBeads() {
            for (let i = 0; i < NUM_RODS; i++) {
                rods[i].forEach(bead => bead.pushed = false);
                recalculateRodBeads(i);
            }
            updateTotalValue(); 
        }

        function updateTotalValue() {
            let totalValue = 0n;
            
            for (let i = 0; i < NUM_RODS; i++) {
                const rodPower = NUM_RODS - 1 - i;
                const rodBeads = rods[i];
                let rodValue = rodBeads.reduce((sum, bead) => sum + (bead.pushed ? bead.value : 0), 0);
                totalValue += BigInt(rodValue) * (10n ** BigInt(rodPower));
            }

            valueDisplay.textContent = totalValue.toLocaleString('en-US');
        }

        // --- EVENT LISTENERS ---
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('click', handleClick);

        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);

        // --- START ---
        window.onload = initAbacus;
    </script>
</body>
</html>
